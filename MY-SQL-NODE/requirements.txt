*UPDATE BASE ON FILTER
  UPDATE <table_name> SET <column_name> = <value> WHERE <inique_identifier> = <matching_values

*UPDATE ALL
  UPDATE <table_name> SET <field> = <value>

* UPDATE users
  SET is_verified = 1
  WHERE id BETWEEN 1 AND 4;

* SELECT username, is_verified, email
  FROM users;
* SELECT username, is_verified, email FROM users WHERE is_verified = true;

* UPDATE users SET is_verified = false

* DELETE FROM users
  WHERE id = 5;

* SELECT if FROM users

* TRUNCATE users; is to emty all record
* DROP DATBASE; is to DELETE DATBASE

* ALTER TABLE employes
  MODIFY COLUMN first_name VARCHAR(29) NOT NULL,
  MODIFY COLUMN last_name VARCHAR(20) NOT NULL,
  MODIFY COLUMN gender VARCHAR(23) NOT NULL,
  MODIFY COLUMN date_of_birth VARCHAR(24) NULL,
  MODIFY COLUMN hire_date VARCHAR(30) NULL,
  MODIFY COLUMN created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  MODIFY COLUMN updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;
  

* SELECT COUNT(*) AS total_male
  FROM employes
  WHERE gender = 'M';
            OR 
*  SELECT COUNT(gender) AS total_male FROM employes WHERE gender = 'M';
            OR 
*  SELECT gender, COUNT(gender) AS gender_count FROM employes GROUP BY  gender;

DATE === YYYY-MM-DD
TIME === HH-MM-SS
DATETIM === YYYY-MM-DD  === HH-MM-SS
TIMESTAMP === YYYY-MM-DD  === HH-MM-SS
YEAR === YYYY

ALTER is use FOR ALTRING A TABLE 



CONSTRAINTS is a rule you apply to a column or table to control what kind of data can be stored in it.

FORREIGNE KEY


CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  first_name VARCHAR(50) NOT NULL,
  last_name VARCHAR(50) NOT NULL,
  email VARCHAR(100) UNIQUE NOT NULL,
  gender CHAR(1) NOT NULL CHECK (gender IN ('M','F')),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);


DELIMITER //

CREATE PROCEDURE seed_products()
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE userId INT;

    WHILE i <= 500 DO
        SET userId = FLOOR(1 + RAND() * 20);
        INSERT INTO products (user_id, product_name, quantity, unit_price, created_at)
        VALUES (
            userId,
            CONCAT('Product_', i),
            FLOOR(1 + RAND() * 100),
            ROUND(10 + RAND() * 1000, 2),
            NOW() - INTERVAL FLOOR(RAND() * 365) DAY
        );
        SET i = i + 1;
    END WHILE;
END //

DELIMITER ;
CALL seed_products();


TASK 3
QUESTION ===== Retrieve all products that have a specific quantity (e.g., 50 units).

  *SELECT * FROM products WHERE quantity = 50;


TASK 4
QUESTION ====== Find all products created between January 1, 2025, and March 31, 2025.

  *SELECT * FROM products where created_at BETWEEN '2025-01-01' AND '2025-03-31';


TASK 5 
QUESTION ====== Compute the total quantity available for each product name.

  *SELECT product_name, SUM(quantity) AS total_quantity FROM products GROUP BY product_name;


TASK 6
QUESTION ====== For each user, calculate the total stock value = (quantity * unit_price).

  *SELECT user_id, SUM(quantity * unit_price) AS total_stock_value FROM products GROUP BY user_id;

TASK 7
QUESTION ====== Example 1: Update all products below quantity 5 to quantity 10.
QUESTION ====== Example 2: Update user email format to a new domain: @dbmaniac.com

   *UPDATE products SET quantity = 10 WHERE quantity < 5;
    *UPDATE users SET email = CONCAT(SUBSTRING_INDEX(email, '@', 1), '@dbmaniac.com');

GO AND STUDY ABOUT DATABASE NORMALIZATION
GO AND LEARN DOCKER COMPOSE AND HOW TO 
GO AND LEARN HOT RELOAD 
GO AND CONNECT YOUR TODO API IT TO DATABASE

PRIMARY KEY ===== is a key that is iniquely identifie record in the table
FORREIGNE KEY ===== is a key that s referency PRIMARY key of a parent table to a child table

CREATE TABLE user (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

the only way we can join table is by maping user id 

What is Database Normalization?
Database normalization is the process of organizing data in a database

Why We Normalize a Database
To remove duplicate data (redundancy).
To make data updates easier and safer.
To keep data consistent (no conflicting information).
To make queries more efficient and logical.

MODEL VIEW CONTROLLER 
MODEL BIEW TEMPLATE

What Is a Model?
In programming — especially in backend frameworks like FastAPI, Django, or Flask —
a model is a blueprint or structure that defines what your data looks like.

creat a controller where your controllers will be 

creat a user and creat a todo and each todo  must have a user u will get all to an get user by todo